<!DOCTYPE html>
<meta charset="utf-8">
<meta title="austenmania, viz 1">
<!--For original raw data processing, overall explanations,
   and walkthrough up until the actual implementation of the multi-brush (which is below),
   go to this shared notebook, https://observablehq.com/d/3e49962e0f6fe721.
   
   With limited time and more familiarity with html/js than the observable environment, 
   I pivoted to this standalone version as global vars became increasingly complex.
   See below for citations!-->
<style>

.grid-background {
  fill: #eee;
}

.grid line,
.grid path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

</style>

<body>
   
<script src="https://d3js.org/d3.v6.min.js"></script>

<script>

d3.json("/nested_paragraphs/Austen_PrideAndPrejudice_nested_paragraphs.json").then(function(nestedData) { 
  
/*BASIC SET-UP*//////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
   const plotVars = ({
      plotWidth: 1060,   // Width of plot region
      plotHeight: 1000,  // Height of plot region
      plotMargin: 30,   // Margin space for axes and their labels
      plotMarginLeft: 60   // Margin space for axes and their labels
   });

   // let lineGenerator = d3.line()
   //    .x(d => xScale(new Date(d.year_month))/* Fill in */) // year_month should go on the x-axis, and apparently need to turn into new Date for functionality
   //    .y(d => yScale(d.screen_time_seconds)/* Fill in */); // screen_time_seconds should go on the y-axis

   // function drawLines(top100Data, plotContainer) {
   //    plotContainer.append("g")
   //       .selectAll("path")
   //       .data(top100Data)
   //       .join("path")
   //       .attr("class", "data-line")               // Class name to be able to access the lines later
   //       .attr("stroke-width", 0.8)
   //       .attr("d", d => lineGenerator(d.values))  // Use lineGenerator on d.values
   //       .attr("fill", "none")                     // Do not fill the area defined by the path
   //       .attr("stroke", d => "gray");   // Set a color for the line (The maps for color is in 'color')
   //    };

   // function drawNames(top100Data, plotContainer) {
   //    plotContainer.append("g")
   //       .selectAll("text.label")
   //       .data(top100Data)
   //       .join("text")
   //       .attr("class", "data-label")
   //       .attr('x', plotVars.plotWidth - plotVars.plotMarginRight + 3)
   //       // Place the ticks at the same y position as
   //       // the last y value of the line (remember, d.va;ues is our array of points)
   //       .attr('y', d => yScale(d.values[d.values.length - 1].screen_time_seconds))
   //       .attr('dy', '0.35em')
   //       .style('fill', d => "gray")
   //       .style('font-family', 'sans-serif')
   //       .style('font-size', 12)
   //       .text(d => d.person)
   // };
   //    plotContainer.append("text")      // text label for the x axis
   //       .attr("x", plotVars.plotWidth / 2 )
   //       .attr("y", plotVars.plotHeight - plotVars.plotMargin/3)
   //       .style('font-family', 'sans-serif')
   //       .style('font-size', 14)
   //       .style("text-anchor", "middle")
   //       .text("Date (in Year-Months)");

   //    plotContainer.append('g')
   //       .attr('class', 'y-axis')
   //       .attr('transform', `translate(${ plotVars.plotMargin},0)`)
   //       .call(yAxis);
      
   //    plotContainer.append("text")
   //       .attr("y", plotVars.plotHeight / 2 )
   //       .attr("x", 20)
   //       .attr("style", "writing-mode: tb; glyph-orientation-vertical: 90")
   //       .attr("dy", "1em")
   //       .style('font-family', 'sans-serif')
   //       .style('font-size', 14)
   //       .style("text-anchor", "middle")
   //       .text("Screen Time (in Seconds)");
   // };
   
   // yAxis = d3.axisLeft(yScale)
   //       .tickFormat(d => d3.format('~s')(d));
   // //const formatter = d3.format('~s'); //https://github.com/d3/d3-format/blob/v1.4.2/README.md#locale_format

/*RENDERING PORTION*//////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
   let xScale = d3.scaleLinear()
        .domain([0, nestedData.length])
        .range([plotVars.plotMarginLeft, plotVars.plotWidth])
   
   let yScale = d3.scaleLinear()
        .domain([0, 80]) //max val found via corpus script, choice to keep max value consistent across different novels
        .range([plotVars.plotMargin, plotVars.plotHeight - plotVars.plotMargin]);
        
   let svgContainer = d3.select("body")
      .append("svg")
      .attr("width", plotVars.plotWidth)
      .attr("height", plotVars.plotHeight)
      .style("background-color", "white")
      .style("border", "1px solid gray");

      svgContainer.selectAll('rect')
         .data(nestedData)
         .enter()
         .append('g')
         .each(function(d, chapterInd) {
            d3.select(this).selectAll('rect')
            .data(d.paragraphs)
            .enter()
            .append('rect')
            .attr('x', function() { 
               return xScale(chapterInd); 
            })
            .attr('y', function(paragraph, parInd) { 
               return yScale(parInd);
            })
            .attr("rx", 1.5) //rounded corners for "friendly" feeling
            .attr("ry", 1.5)
            .attr('height', function(paragraph) { 
               let paragraphSize = Math.ceil(paragraph.length / 100) * 100 * 0.0031; //round to nearest 100 words
               return paragraphSize;    
            })
            .attr('width', function(paragraph, parInd) { //vertical length of paragraph
               return 14;
            })
            .attr('fill', "forestgreen")
         });

      svgContainer.append("g")
         .selectAll("text.chapter")
         .data(nestedData)
         .join("text")
         .attr("class", "text-chapter")
         .attr('x', function(d, chapterInd) { 
            return xScale(chapterInd); 
         })
         .attr('y', plotVars.plotMargin - 4)
         .style('fill', "black")
         .style('font-family', 'Georgia')
         .style('font-size', 12)
         .text(d => d.chapter);
   
////*Static tick-making and explainers*/////
   let xAxis = d3.axisTop(xScale);
   let yAxis = d3.axisLeft(yScale);
      
   function drawTicks(plotContainer) {

      plotContainer.append('g')
         .attr('class', 'x-axis')
         .attr('transform', `translate(0,${ plotVars.plotMargin })`);
      
      plotContainer.append('g')
         .attr('class', 'y-axis')
         .attr('transform', `translate(${plotVars.plotMargin*1.5}, 0)`)
         .style('font-family', 'Georgia')
         .call(yAxis);

      plotContainer.append("text")
         .attr("y", plotVars.plotHeight / 3)
         .attr("x", 10)
         .attr("style", "writing-mode: tb; glyph-orientation-vertical: 90")
         .attr("dy", "1em")
         .style('font-family', 'Georgia')
         .style('font-size', 16)
         .style("text-anchor", "middle")
         .text("# of Paragraphs per Chapter");
   };
   
   drawTicks(svgContainer);
   
});

</script>

<div>
   <h3>austenmania</h3>
</div>
