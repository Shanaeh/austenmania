<!DOCTYPE html>
<meta charset="utf-8">
<meta title="austenmania, viz 1">
<!--For original raw data processing, overall explanations,
   and walkthrough up until the actual implementation of the multi-brush (which is below),
   go to this shared notebook, https://observablehq.com/d/3e49962e0f6fe721.
   
   With limited time and more familiarity with html/js than the observable environment, 
   I pivoted to this standalone version as global vars became increasingly complex.
   See below for citations!-->
<style>

.grid-background {
  fill: #eee;
}

.grid line,
.grid path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

</style>

<body>
<div>
   <h3>austenmania</h3>
</div>
<script src="https://d3js.org/d3.v6.min.js"></script>

<input type="text" value="marriage" id="keywordSearch">
<button type="button" id="keywordSearchButton" onclick="searchKeywordOnClick()">Search for a term</button>
<script>

   ////*HTML button helper, outside d3 file sharing*////
   let selectedKeyword = keywordSearch.value;
   function searchKeywordOnClick() {
      selectedKeyword = keywordSearch.value;
   }

d3.json("/nested_paragraphs/Austen_PrideAndPrejudice_nested_paragraphs.json").then(function(nestedData) { 
////*Set-up, constants, and functions*////

   const plotVars = ({
      plotWidth: 1060,   // Width of plot region
      plotHeight: 1000,  // Height of plot region
      plotMargin: 30,   // Margin space for axes and their labels
      plotMarginLeft: 60   // Margin space for axes and their labels
   });

   let keywordSearch = document.getElementById("keywordSearch");
      // Execute a function when the user releases a key on the keyboard
   keywordSearch.addEventListener("keyup", function(event) {
   // Number 13 is the "Enter" key on the keyboard
   if (event.keyCode === 13) {
      // Cancel the default action, if needed
      console.log(keywordSearch.value);
      event.preventDefault();
      // Trigger the button element with a click
      document.getElementById("keywordSearchButton").click();
   }
   });

   d3.select("#keywordSearchButton").on("click", function() {
         console.log(selectedKeyword);

         //add more stuff to change
   });

   const numChapters = nestedData.length;
   function getMaxNumParagraphs() {
      let maxParagraphs = 0;
      for(let i=0; i < numChapters; i++) {
         const numParagraphs = nestedData[i].paragraphs.length;
         if(maxParagraphs < numParagraphs) {
            maxParagraphs = numParagraphs;
         }
      }
      return maxParagraphs;
   }
   const maxNumParagraphs = getMaxNumParagraphs();

   let xScale = d3.scaleLinear()
        .domain([0, nestedData.length])
        .range([plotVars.plotMarginLeft, plotVars.plotWidth])

   let yScale = d3.scaleLinear()
        .domain([0, maxNumParagraphs]) ////103 wanted consistency for comparison across different novels, 103 is the max
        .range([plotVars.plotMargin, plotVars.plotHeight - plotVars.plotMargin]);
  
/*RENDERING PORTION*//////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
   let svgContainer = d3.select("body")
      .append("svg")
      .attr("width", plotVars.plotWidth)
      .attr("height", plotVars.plotHeight)
      .style("background-color", "white")
      .style("border", "1px solid gray");

      svgContainer.selectAll('rect')
         .data(nestedData)
         .enter()
         .append('g')
         .each(function(d, chapterInd) {
            d3.select(this).selectAll('rect')
            .data(d.paragraphs)
            .enter()
            .append('rect')
            .attr('x', function() { 
               return xScale(chapterInd); 
            })
            .attr('y', function(paragraph, parInd) { 
               return yScale(parInd);
            })
            .attr("rx", 1.5) //rounded corners for "friendly" feeling
            .attr("ry", 1.5)
            .attr('height', function(paragraph) { 
               let paragraphSize = Math.ceil(paragraph.length / 100) * 100 * 0.0031; //round to nearest 100 words
               return paragraphSize;    
            })
            .attr('width', function(paragraph, parInd) { //vertical length of paragraph
               return 14;
            })
            .attr('fill', "forestgreen")
         });

      svgContainer.append("g")
         .selectAll("text.chapter")
         .data(nestedData)
         .join("text")
         .attr("class", "text-chapter")
         .attr('x', function(d, chapterInd) { 
            return xScale(chapterInd); 
         })
         .attr('y', plotVars.plotMargin - 4)
         .style('fill', "black")
         .style('font-family', 'Georgia')
         .style('font-size', 13)
         .text(d => d.chapter);
   
////*Static tick-making and explainers*/////
   let xAxis = d3.axisTop(xScale);
   let yAxis = d3.axisLeft(yScale);
      
   function drawTicks(plotContainer) {

      plotContainer.append('g')
         .attr('class', 'x-axis')
         .attr('transform', `translate(0,${ plotVars.plotMargin })`);
      
      plotContainer.append('g')
         .attr('class', 'y-axis')
         .attr('transform', `translate(${plotVars.plotMargin*1.5}, 0)`)
         .style('font-family', 'Georgia')
         .call(yAxis);

      plotContainer.append("text")
         .attr("y", plotVars.plotHeight / 3)
         .attr("x", 10)
         .attr("style", "writing-mode: tb; glyph-orientation-vertical: 90")
         .attr("dy", "1em")
         .style('font-family', 'Georgia')
         .style('font-size', 16)
         .style("text-anchor", "middle")
         .text("# of Paragraphs per Chapter");
   };
   
   drawTicks(svgContainer);
   
});

</script>

</body>
</html>